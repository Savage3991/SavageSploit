package main

import (
	"bufio"
	"fmt"
	"strconv"
	"strings"
	"time"

	"github.com/zyantific/zydis-go"

	"main/packages/loader"
	"main/packages/patterns"
	"main/packages/scanner"

	"github.com/iskaa02/qalam/gradient"
)

var g, _ = gradient.NewGradient("#EAAECC", "#EDB7CB", "#E6A5CC")

func main() {

	fmt.Println(g.Mutline(fmt.Sprintf(`
  _                       
 | |                      
 | |    _   _ _ __   __ _ 
 | |   | | | | '_ \ / _' |
 | |___| |_| | | | | (_| |
 |______\__,_|_| |_|\__,_|

Generated by http2 @ %v %v
`, time.Now().Format(time.DateOnly), time.Now().Format(time.Kitchen))))

	loader.LoadPath(`C:\Users\Brand\Desktop\Important\vulkan-main\roblox.exe`)
	if loader.Decoder.Base == 0 {
		g.Print("[ERROR] Unable to get Decoder.Base address..\n")
		return
	}
	/*
		if r := scanner.BulkScanQueues([]scanner.Queue{
			scanner.CreateDefaultQueue(",\"source\":\""),
			scanner.CreateDefaultQueue("{\"type\":\"string\",\"cat\":%d,\"size\":%d,\"data\":\""),
			scanner.CreateDefaultQueue(",\"protos\":["),
		}); len(r) > 0 {
			if result, ok := r[",\"protos\":["]; ok {
				jmpAddr := scanner.FindNext(result[0], zydis.MNEMONIC_JLE, 0)
				loopStart := scanner.FindNext(jmpAddr, zydis.MNEMONIC_MOV, 2)
				callAddr := scanner.FindNext(loopStart, zydis.MNEMONIC_CALL, 2)
				mathAddr := scanner.FindPrevious(callAddr, zydis.MNEMONIC_MOV, zydis.OPERAND_TYPE_MEMORY, 0)
				f := scanner.ReturnPattern(
					mathAddr,
				)
				fmt.Println(f)
				fmt.Printf("0x%x\n", loader.Rebase(scanner.FindNext(scanner.FindFunctionStart(result[0], 0x10), zydis.MNEMONIC_MOV, 26)))
				fmt.Println(scanner.GetVMValueType(f))
				//os.Exit(0)
			}
			if result, ok := r["{\"type\":\"string\",\"cat\":%d,\"size\":%d,\"data\":\""]; ok {
				fmt.Println("TSTRING_LEN_ENC : " + scanner.GetVMValueType(scanner.ReturnPattern(
					scanner.FindNext(result[0], zydis.MNEMONIC_SUB, 1),
				)))
			}
			if result, ok := r[",\"source\":\""]; ok {
				fmt.Println("PROTO_MEMBER2_ENC : " + scanner.GetVMValueType(
					scanner.ReturnPattern(
						scanner.FindNext(
							result[0],
							zydis.MNEMONIC_MOV,
							0,
						),
					),
				))
			}
		}

		os.Exit(0)*/

	//var Base = loader.Decoder.Base + uintptr(0x88113d)

	var Builder string

	if r := scanner.BulkScanQueues([]scanner.Queue{
		scanner.CreateDefaultQueue("proximityPromptOnHeartbeat"),
		scanner.CreateDefaultQueue("new overlap in different world"),
		scanner.CreateDefaultQueue("RBX::Runtime - panic \"!owns_lock() && \\\"Thread attempted to wait for Lock that it already owns.\\\"\""),
		{Data: "spawn", ResultsExpected: 0, RDataOnly: true, ScanCode: true, StopFirst: false},
		scanner.CreateDefaultQueue("Maximum re-entrancy depth (%i) exceeded"),
		scanner.CreateDefaultQueue("Script Start"),
		scanner.CreateDefaultQueue("loadstring"),
		scanner.CreateDefaultQueue("Current identity is %d"),
		scanner.CreateDefaultQueue("Event %s.%s is not safe to access in parallel"),
		scanner.CreateDefaultQueue("initialThermalStatus"),
		scanner.CreateDefaultQueue("Maximum re-entrancy depth (%i) exceeded calling task.defer"),
		scanner.CreateDefaultQueue("OverlapParams"),
		scanner.CreateDefaultQueue("'%s' is not a valid member of %s"),
		scanner.CreateDefaultQueue("EnableLoadModule"),
		scanner.CreateDefaultQueue("oldResult, moduleRef  = ...\nnewResult = require(moduleRef)\nt1 = newResult\nt2 = oldResult\nif type(t2) ~= \"table\" then return end\nfor k,v in pairs(t2) do\n    if type(t1[k]) == \"nil\" then \n        t2[k] = nil\n    end\nend\nfor k,v in pairs(t1) do\n    t2[k] = v\nend\n"),
		scanner.CreateDefaultQueue("require(assetId) cannot be called from a client.  assetId = %lld"),
		scanner.CreateDefaultQueue("finish_init_lua_begin"),
		scanner.CreateDefaultQueue("Failed to create Lua state"),
		scanner.CreateDefaultQueue(",\"pairs\":["),
		scanner.CreateDefaultQueue("unordered_map/set too long"),
		scanner.CreateDefaultQueue("assembly clump is null"),
		scanner.CreateDefaultQueue("Invalid table key type used"),
		scanner.CreateDefaultQueue("Trying to call method on object of type: `%s` with incorrect arguments."),
		scanner.CreateDefaultQueue("The metatable is locked"),
		scanner.CreateDefaultQueue("GetFVariable"),
	}); len(r) > 0 {
		// Print
		if result, ok := r["Current identity is %d"]; ok && len(result) > 0 {
			Builder += (fmt.Sprintf("[LOG] %v %v | Print | 0x%x\n", time.Now().Format(time.DateOnly), time.Now().Format(time.Kitchen), loader.Rebase(
				scanner.ResolveDataRef(
					scanner.FindNext(result[0]-0x3D, zydis.MNEMONIC_CALL, 1),
					0,
				),
			)))
		}
		// LuaH_DummyNode
		if result, ok := r[",\"pairs\":["]; ok && len(result) > 0 {
			Builder += (fmt.Sprintf("[LOG] %v %v | LuaH_DummyNode | 0x%x\n", time.Now().Format(time.DateOnly), time.Now().Format(time.Kitchen), loader.Rebase(
				scanner.ResolveDataRef(scanner.FindNext(scanner.FindFunctionStart(result[0], 0x0), zydis.MNEMONIC_LEA, 1), 1),
			)))
		}
		// unk_LuaO_nilobject
		if result, ok := r["'%s' is not a valid member of %s"]; ok && len(result) > 0 {
			Builder += (fmt.Sprintf("[LOG] %v %v | LuaO_nilobject | 0x%x\n", time.Now().Format(time.DateOnly), time.Now().Format(time.Kitchen), loader.Rebase(
				scanner.ResolveDataRef(scanner.FindNext(scanner.ResolveDataRef(
					scanner.FindNext(result[0]-0x50, zydis.MNEMONIC_CALL, 0),
					0,
				), zydis.MNEMONIC_LEA, 0), 1),
			)))
		}
		// sub_LuaO_nilobject
		if result, ok := r["OverlapParams"]; ok && len(result) > 0 {
			Builder += (fmt.Sprintf("[LOG] %v %v | LuaO_nilobject | 0x%x\n", time.Now().Format(time.DateOnly), time.Now().Format(time.Kitchen), loader.Rebase(
				scanner.ResolveDataRef(
					scanner.FindNext(result[0], zydis.MNEMONIC_CALL, 0),
					0,
				),
			)))
		}
		// LuaC_Step, LuaD_Throw
		if result, ok := r["The metatable is locked"]; ok && len(result) > 0 {
			addr := scanner.FindFunctionStart(result[0], 0x0)
			Builder += (fmt.Sprintf("[LOG] %v %v | LuaC_Step | 0x%x\n", time.Now().Format(time.DateOnly), time.Now().Format(time.Kitchen), loader.Rebase(
				scanner.ResolveDataRef(scanner.FindNext(addr, zydis.MNEMONIC_CALL, 0), 0),
			)))
			Builder += (fmt.Sprintf("[LOG] %v %v | LuaD_Throw  | 0x%x\n", time.Now().Format(time.DateOnly), time.Now().Format(time.Kitchen), loader.Rebase(
				scanner.ResolveDataRef(
					scanner.FindNext(
						scanner.FindNext(addr, zydis.MNEMONIC_TEST, 9),
						zydis.MNEMONIC_CALL,
						15,
					),
					0,
				),
			)))
		}
		// KTable
		if result, ok := r["Trying to call method on object of type: `%s` with incorrect arguments."]; ok && len(result) > 0 {
			Builder += (fmt.Sprintf("[LOG] %v %v | KTable | 0x%x\n", time.Now().Format(time.DateOnly), time.Now().Format(time.Kitchen), loader.Rebase(
				scanner.FindGlobalRef(
					scanner.FindNext(scanner.FindFunctionStart(result[0], 0x0), zydis.MNEMONIC_LEA, 3),
					zydis.REGISTER_RIP,
				),
			)))
		}
		// AppDataInfo
		if result, ok := r["RBX::Runtime - panic \"!owns_lock() && \\\"Thread attempted to wait for Lock that it already owns.\\\"\""]; ok && len(result) > 0 {
			Builder += (fmt.Sprintf("[LOG] %v %v | AppDataInfo | 0x%x\n", time.Now().Format(time.DateOnly), time.Now().Format(time.Kitchen), loader.Rebase(
				scanner.ResolveDataRef(
					scanner.FindNext(
						scanner.ResolveDataRef(
							scanner.FindGlobalRef(
								scanner.FindFunctionStart(
									result[0], 0x0)-0x5,
								zydis.REGISTER_RAX,
							),
							0,
						),
						zydis.MNEMONIC_LEA,
						0,
					),
					1,
				),
			)))
		}
		// TaskSpawn
		if result, ok := r["spawn"]; ok && len(result) > 0 {
			Builder += (fmt.Sprintf("[LOG] %v %v | TaskSpawn | 0x%x\n", time.Now().Format(time.DateOnly), time.Now().Format(time.Kitchen), loader.Rebase(
				scanner.FindFunctionStart(result[1], 0x10),
			)))
		}
		// TaskDefer
		if result, ok := r["Maximum re-entrancy depth (%i) exceeded calling task.defer"]; ok && len(result) > 0 {
			Builder += (fmt.Sprintf("[LOG] %v %v | TaskDefer | 0x%x\n", time.Now().Format(time.DateOnly), time.Now().Format(time.Kitchen), loader.Rebase(
				scanner.FindFunctionStart(result[0], 0x10),
			)))
		}
		// FireTouchInterest
		if result, ok := r["new overlap in different world"]; ok && len(result) > 0 {
			Builder += (fmt.Sprintf("[LOG] %v %v | FireTouchInterest | 0x%x\n", time.Now().Format(time.DateOnly), time.Now().Format(time.Kitchen), loader.Rebase(
				scanner.ResolveDataRef(
					scanner.FindNext(result[0], zydis.MNEMONIC_CALL, 1),
					0,
				),
			)))
		}
		// FireProximityPrompt
		if result, ok := r["proximityPromptOnHeartbeat"]; ok && len(result) > 0 {
			Builder += (fmt.Sprintf("[LOG] %v %v | FireProximityPrompt | 0x%x\n", time.Now().Format(time.DateOnly), time.Now().Format(time.Kitchen), loader.Rebase(
				scanner.ResolveDataRef(
					scanner.FindNext(
						scanner.FindNext(
							scanner.FindFunctionStart(result[0], 0x10),
							zydis.MNEMONIC_JZ,
							10,
						),
						zydis.MNEMONIC_CALL,
						2,
					),
					0,
				),
			)))
		}
		// GetValue
		if result, ok := r["GetFVariable"]; ok && len(result) > 0 {
			Builder += (fmt.Sprintf("[LOG] %v %v | GetValue | 0x%x\n", time.Now().Format(time.DateOnly), time.Now().Format(time.Kitchen), loader.Rebase(
				scanner.FindGlobalRef(result[0]-0x30, zydis.REGISTER_RIP))))
		}
		// DecryptLuaState
		if result, ok := r["Script Start"]; ok && len(result) > 0 {

			Builder += (fmt.Sprintf("[LOG] %v %v | DecryptLuaState | 0x%x\n", time.Now().Format(time.DateOnly), time.Now().Format(time.Kitchen), loader.Rebase(
				scanner.ResolveDataRef(
					scanner.FindNext(result[0]-0x3D, zydis.MNEMONIC_CALL, 1),
					0,
				),
			)))

			fmt.Printf("0x%x\n", loader.Rebase(result[0]))

			Builder += (fmt.Sprintf(
				"[LOG] %v %v | GetGlobalState | 0x%x\n",
				time.Now().Format(time.DateOnly),
				time.Now().Format(time.Kitchen),
				loader.Rebase(scanner.ResolveDataRef(
					scanner.FindPrevious(result[0], zydis.MNEMONIC_CALL, zydis.OPERAND_TYPE_IMMEDIATE, 0),
					0,
				)),
			))

		}
		// GetContextObject, LuaVM::Load, LuaU_Load OpCodeTable
		if result, ok := r["loadstring"]; ok && len(result) > 0 {
			// getcontextobject
			call := scanner.FindNext(result[0]-0x3D, zydis.MNEMONIC_CALL, 1)
			call = scanner.FindNext(call, zydis.MNEMONIC_CMP, 0)
			call = scanner.FindNext(call, zydis.MNEMONIC_JZ, 0)
			call = scanner.FindNext(call, zydis.MNEMONIC_CALL, 1)
			Builder += (fmt.Sprintf(
				"[LOG] %v %v | GetContextObject | 0x%x\n",
				time.Now().Format(time.DateOnly),
				time.Now().Format(time.Kitchen),
				loader.Rebase(scanner.ResolveDataRef(
					call,
					0,
				))))
			// luavmload
			luavm_load := scanner.ResolveDataRef(
				scanner.FindNext(
					scanner.FindNext(
						result[0],
						zydis.MNEMONIC_CMP,
						0),
					zydis.MNEMONIC_CALL,
					4),
				0,
			)
			Builder += fmt.Sprintf(
				"[LOG] %v %v | LuaVM::Load | 0x%x\n",
				time.Now().Format(time.DateOnly),
				time.Now().Format(time.Kitchen),
				loader.Rebase(luavm_load),
			)
			Builder += fmt.Sprintf(
				"[LOG] %v %v | LuaU_Load OpCodeTable | 0x%x\n",
				time.Now().Format(time.DateOnly),
				time.Now().Format(time.Kitchen),
				scanner.FindGlobalRef(
					scanner.FindNext(scanner.FindNext(luavm_load, zydis.MNEMONIC_JNBE, 7),
						zydis.MNEMONIC_MOVZX, 4,
					),
					zydis.REGISTER_RCX),
			)
		}
		// ScriptContextResume, ScriptContextResumeOffset
		if result, ok := r["Maximum re-entrancy depth (%i) exceeded"]; ok && len(result) > 0 {
			call := scanner.ResolveDataRef(
				scanner.FindNext(result[0], zydis.MNEMONIC_CALL, 1),
				0,
			)
			Builder += (fmt.Sprintf("[LOG] %v %v | ScriptContextResume | 0x%x\n", time.Now().Format(time.DateOnly), time.Now().Format(time.Kitchen), loader.Rebase(
				call,
			)))
			offset, _ := strconv.Atoi(strings.Replace(fmt.Sprintf("%v", (int64)(scanner.FindGlobalRef(
				scanner.FindNext(call, zydis.MNEMONIC_LEA, 1),
				zydis.REGISTER_R13,
			))), "-", "", 1))
			Builder += (fmt.Sprintf("[LOG] %v %v | ScriptContextResumeOffset | 0x%x\n", time.Now().Format(time.DateOnly), time.Now().Format(time.Kitchen), offset))
		}
		// Luau_execute
		if result, ok := r["Invalid table key type used"]; ok && len(result) > 0 {
			Builder += (fmt.Sprintf("[LOG] %v %v | Luau_execute | 0x%x\n", time.Now().Format(time.DateOnly), time.Now().Format(time.Kitchen), loader.Rebase(
				scanner.ResolveDataRef(
					scanner.FindNext(
						scanner.FindPrevious(scanner.FindNext(
							scanner.ResolveDataRef(
								scanner.FindNext(
									scanner.FindPrevious(result[0],
										zydis.MNEMONIC_CALL,
										zydis.OPERAND_TYPE_MEMORY,
										0,
									),
									zydis.MNEMONIC_CALL,
									8,
								),
								0,
							),
							zydis.MNEMONIC_RET, 0),
							zydis.MNEMONIC_CALL,
							zydis.OPERAND_TYPE_MAX_VALUE,
							9)-0x1000,
						zydis.MNEMONIC_CALL, 7),
					0,
				),
			)))
		}
		// GetAssemblyPrimitive
		if result, ok := r["assembly clump is null"]; ok && len(result) > 0 {
			Builder += (fmt.Sprintf("[LOG] %v %v | GetAssemblyPrimitive | 0x%x\n", time.Now().Format(time.DateOnly), time.Now().Format(time.Kitchen), loader.Rebase(
				scanner.ResolveDataRef(
					scanner.FindNext(
						scanner.FindNext(scanner.FindFunctionStart(result[0], 0x16), zydis.MNEMONIC_JMP, 9),
						zydis.MNEMONIC_CALL, 6,
					),
					0,
				),
			)))
		}
		// GetFromVMStateMap
		if result, ok := r["unordered_map/set too long"]; ok && len(result) > 0 {
			Builder += (fmt.Sprintf("[LOG] %v %v | GetFromVMStateMap | 0x%x\n", time.Now().Format(time.DateOnly), time.Now().Format(time.Kitchen), loader.Rebase(
				scanner.FindFunctionStart(result[0], 0x20),
			)))
		}
		// EnableLoadModule
		if result, ok := r["EnableLoadModule"]; ok && len(result) > 0 {
			Builder += (fmt.Sprintf("[LOG] %v %v | EnableLoadModule | 0x%x\n", time.Now().Format(time.DateOnly), time.Now().Format(time.Kitchen), loader.Rebase(
				scanner.ResolveDataRef(
					scanner.FindNext(result[0]-0x20, zydis.MNEMONIC_LEA, 0),
					1,
				),
			)))
		}
		// SetProtoCapabilities, PushInstance
		if result, ok := r["oldResult, moduleRef  = ...\nnewResult = require(moduleRef)\nt1 = newResult\nt2 = oldResult\nif type(t2) ~= \"table\" then return end\nfor k,v in pairs(t2) do\n    if type(t1[k]) == \"nil\" then \n        t2[k] = nil\n    end\nend\nfor k,v in pairs(t1) do\n    t2[k] = v\nend\n"]; ok && len(result) > 0 {
			if len(result) < 1 {
				return
			}
			Builder += (fmt.Sprintf("[LOG] %v %v | SetProtoCapabilities | 0x%x\n", time.Now().Format(time.DateOnly), time.Now().Format(time.Kitchen), loader.Rebase(
				scanner.ResolveDataRef(
					scanner.FindNext(result[0], zydis.MNEMONIC_CALL, 13),
					0,
				),
			)))
			Builder += (fmt.Sprintf("[LOG] %v %v | PushInstance | 0x%x\n", time.Now().Format(time.DateOnly), time.Now().Format(time.Kitchen), loader.Rebase(
				scanner.ResolveDataRef(
					scanner.FindNext(result[0], zydis.MNEMONIC_CALL, 17),
					0,
				),
			)))
		}
		// GetTaskSchedular, GetTaskSchedularPointer
		if result, ok := r["initialThermalStatus"]; ok && len(result) > 0 {
			call := scanner.ResolveDataRef(
				scanner.FindNext(scanner.FindFunctionStart(result[0], 0x0), zydis.MNEMONIC_CALL, 2),
				0,
			)
			Builder += (fmt.Sprintf("[LOG] %v %v | GetTaskSchedular | 0x%x\n", time.Now().Format(time.DateOnly), time.Now().Format(time.Kitchen), loader.Rebase(
				call,
			)))
			Builder += (fmt.Sprintf("[LOG] %v %v | GetTaskSchedularPointer | 0x%x\n", time.Now().Format(time.DateOnly), time.Now().Format(time.Kitchen), loader.Rebase(
				scanner.ResolveDataRef(scanner.FindNext(scanner.FindNext(call, zydis.MNEMONIC_CMP, 1), zydis.MNEMONIC_MOV, 0), 0),
			)))
		}
		// GetProperty
		if result, ok := r["Event %s.%s is not safe to access in parallel"]; ok && len(result) > 0 {
			Builder += (fmt.Sprintf("[LOG] %v %v | GetProperty | 0x%x\n", time.Now().Format(time.DateOnly), time.Now().Format(time.Kitchen), loader.Rebase(
				scanner.ResolveDataRef(
					scanner.FindNext(scanner.FindFunctionStart(result[0], 0x0), zydis.MNEMONIC_CALL, 0),
					0,
				),
			)))
		}
		// CastModule
		if result, ok := r["require(assetId) cannot be called from a client.  assetId = %lld"]; ok && len(result) > 0 {
			Builder += fmt.Sprintf(
				"[LOG] %v %v | CastModule | 0x%x\n",
				time.Now().Format(time.DateOnly),
				time.Now().Format(time.Kitchen),
				loader.Rebase(scanner.ResolveDataRef(
					scanner.FindNext(scanner.FindFunctionStart(result[0], 0x0), zydis.MNEMONIC_CALL, 13),
					0,
				)),
			)
		}
		// IdentityStruct, IdentityPointer
		if result, ok := r["finish_init_lua_begin"]; ok && len(result) > 0 {
			identity_struct := scanner.FindNext(scanner.FindFunctionStart(result[0], 0x0), zydis.MNEMONIC_CALL, 3)
			Builder += fmt.Sprintf(
				"[LOG] %v %v | IdentityStruct | 0x%x\n",
				time.Now().Format(time.DateOnly),
				time.Now().Format(time.Kitchen),
				loader.Rebase(scanner.ResolveDataRef(
					identity_struct,
					0,
				)),
			)
			Builder += fmt.Sprintf(
				"[LOG] %v %v | IdentityPointer | 0x%x\n",
				time.Now().Format(time.DateOnly),
				time.Now().Format(time.Kitchen),
				loader.Rebase(scanner.FindGlobalRef(identity_struct, zydis.REGISTER_RIP)),
			)
		}
	}

	for name, offset := range patterns.GetPatterns() {
		if len(offset) > 0 {
			Builder += (fmt.Sprintf("[LOG] %v %v | "+name+" | 0x%x\n", time.Now().Format(time.DateOnly), time.Now().Format(time.Kitchen), loader.Rebase(offset[0])))
		} else {
			Builder += (fmt.Sprintf("[ERR] %v %v | ", time.Now().Format(time.DateOnly), time.Now().Format(time.Kitchen)) + name + " Failed to grab offset.\n")
		}
	}

	scanner := bufio.NewScanner(strings.NewReader(Builder))
	var prefixes []string
	var offsets []string
	var fallbackLines []string
	maxPrefixLen := 0

	for scanner.Scan() {
		line := scanner.Text()
		parts := strings.Split(line, " | ")
		if len(parts) >= 3 {
			prefix := strings.Join(parts[:len(parts)-1], " | ")
			offset := strings.TrimSpace(parts[len(parts)-1])
			if strings.HasPrefix(offset, "0x") {
				prefix = strings.TrimSpace(prefix)
				prefixes = append(prefixes, prefix)
				offsets = append(offsets, offset)
				if len(prefix) > maxPrefixLen {
					maxPrefixLen = len(prefix)
				}
				continue
			}
		}
		fallbackLines = append(fallbackLines, line)
	}

	var toprint, fallback string
	for i, prefix := range prefixes {
		toprint += fmt.Sprintf("%-*s | %s\n", maxPrefixLen, prefix, offsets[i])
		if i+1 == len(prefixes) {
			toprint = toprint[:len(toprint)-1]
		}
	}

	fmt.Print(g.Mutline(toprint))

	if len(fallbackLines) > 0 {
		fallback += ("\n\nFallback log entries (unaligned):\n")
		for _, line := range fallbackLines {
			fallback += (line)
		}
	}
	fmt.Print(g.Mutline(fallback))
}
